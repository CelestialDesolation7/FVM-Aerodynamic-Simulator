# 项目运行全生命周期数据流

---

## 一、程序初始化

### 1.1 CUDA 环境检测（`checkCudaAvailability`）

`main()` 第一件事是调用 `checkCudaAvailability()`，通过 `cudaGetDeviceCount()` 和 `cudaGetDeviceProperties()` 确认 GPU 存在且计算能力 ≥ 7.5（`MIN_COMPUTE_CAPABILITY_MAJOR=7`, `MIN_COMPUTE_CAPABILITY_MINOR=5`）。失败则直接退出。

### 1.2 窗口和 OpenGL 初始化

```
glfwInit() → glfwCreateWindow(1600×900, OpenGL 4.3 Core)
           → glfwMakeContextCurrent()
           → glfwSwapInterval(0)       // 默认关闭垂直同步
           → gladLoadGLLoader()         // 加载 OpenGL 函数指针
```

注册两个 GLFW 回调：
- `framebufferSizeCallback`：窗口尺寸变化时调用 `renderer.resize()`，更新 `glViewport`。
- `keyCallback`：ESC 关闭窗口；Space 切换 `params.paused`；R 设置 `g_resetRequested = true`（原子操作，主循环安全区域处理）。

### 1.3 ImGui 初始化

```
ImGui::CreateContext()
ImGui_ImplGlfw_InitForOpenGL(window, true)
ImGui_ImplOpenGL3_Init("#version 430 core")
setupImGuiFont()   // 加载 assets/fonts/msyh.ttc，支持中文
```

### 1.4 Renderer 初始化（`renderer.initialize()`）

在 GL 线程中完成所有 OpenGL 对象的创建，之后整个生命周期内保持不变：

**着色器编译**：
- 场渲染着色器（`FIELD_VERTEX_SHADER` + `FIELD_FRAGMENT_SHADER`）：绘制全屏四边形，片元从 `fieldTexture`（R32F）采样物理量值，从 `cellTypeTexture` 判断是否固体，查询 1D `colormapTexture` 映射颜色。
- 矢量箭头着色器（`vectorVertexShader` + `vectorFragmentShader`）：逐顶点颜色，无光照。

**GPU 对象创建**：

```
glGenVertexArrays + glGenBuffers → VAO/VBO（全屏四边形，6顶点，静态）
glGenTextures → fieldTexture_（GL_R32F，存物理量）
glGenTextures → cellTypeTexture_（GL_R32F，存网格类型 float 化）
glGenTextures → colormapTexture_（GL_RGB32F，1D 256 点色图）
glGenVertexArrays + glGenBuffers × 2 → vectorVAO_ / vectorVBO_[2]（双缓冲，初始空）
```

色图在 `createColormapTexture()` 中按 `colormap_` 枚举生成 256 个 RGB 样本并上传 1D 纹理。

缓存 uniform 位置（`loc_minVal_`, `loc_maxVal_`），并设置采样器 uniform（`fieldTexture=0, colormapTexture=1, cellTypeTexture=2`）。

### 1.5 仿真器初始化（`initializeSimulation()`）

```
params.computeDerived()              // 由 mach/T_inf/p_inf 推导 rho_inf/u_inf/c_inf/dx/dy
resizeBuffers()                      // h_cellTypes.resize(nx * ny)
solver.initialize(params)            // 分配显存 + reset()
solver.getCellTypes(h_cellTypes)     // 拷贝 d_cell_type_ → 主机
renderer.updateCellTypes(...)        // 主机 uint8 → float → GPU 纹理
renderer.initCudaInterop(nx, ny)     // 创建双缓冲 PBO + 注册 CUDA 图形资源
```

**`solver.initialize(params)` 展开**：

```
_nx = params.nx; _ny = params.ny;
freeMemory();        // 清掉旧指针（首次为空操作）
allocateMemory();    // cudaMalloc 所有显存
reset(params);       // 初始化流场
```

**`allocateMemory()` 显存布局**（以 1024×512 为例约 ~130MB）：

| 数组 | 数量 | 说明 |
|--------|------|------|
| 守恒变量（当前步）| 5× float | `d_rho_, d_rho_u_, d_rho_v_, d_E_, d_rho_e_` |
| 守恒变量（下一步）| 5× float | `d_rho_new_, ...`（双缓冲） |
| 原始变量 | 4× float | `d_u_, d_v_, d_p_, d_T_` |
| 网格/几何 | 1× uint8 + 1× float | `d_cell_type_, d_sdf_` |
| 通量（X 方向）| 5× float | `d_flux_rho_x_, ..., d_flux_rho_e_x_` |
| 通量（Y 方向）| 5× float | `d_flux_rho_y_, ..., d_flux_rho_e_y_` |
| CUB 归约 | 1× 动态 + 1× float | `d_reduction_buffer_, d_reduction_output_` |
| 归约暂存 | 1× float | `d_scratch_`（波速/马赫数等中间值） |
| 粘性相关 | 6× float | `d_mu_, d_tau_xx_, d_tau_yy_, d_tau_xy_, d_qx_, d_qy_` |
| 原子计数器 | 1× int | `d_atomic_counter_`（矢量箭头生成） |

**`reset(params)` 中的 CUDA 核函数链**：

```
initializeKernel          // 全场写入来流守恒变量
computeSDFKernel          // 按障碍物形状计算 SDF 场和 cell_type
applyBoundaryConditions   // 写入 INFLOW/OUTFLOW/GHOST 边界状态
computePrimitivesKernel   // 守恒量→原始量（双能量法）
computeViscousTermsKernel // 计算 mu/tau/q（确保首次 CFL 计算时 d_mu_ 有效）
cudaDeviceSynchronize()
```

**`initCudaInterop(nx, ny)` 展开**：

```
glGenBuffers(2, fieldPBO_)                    // 两个 PBO，每个 nx*ny*4 字节
cudaGraphicsGLRegisterBuffer(PBO[0], WRITE_DISCARD)
cudaGraphicsGLRegisterBuffer(PBO[1], WRITE_DISCARD)
glTexImage2D(fieldTexture_, GL_R32F, nx, ny)  // 确保纹理尺寸正确
writeIndex_ = 0
mapFieldForWriting()                           // 预映射 PBO[0]，得到 mappedFieldPtr_
```

`fieldPBO_[2]` 中始终有一个被 CUDA 映射（供 Solver 线程写入），另一个被 GL 用于纹理上传，二者永不重叠。矢量 VBO 双缓冲在首次需要时由 `ensureVectorVBOCapacity()` 延迟创建。

### 1.6 启动求解器线程

```cpp
g_solverThread = std::thread(solverThreadFunc);
```

求解器线程立即进入等待状态（`g_solverState == IDLE`），等待主线程发出 `RUNNING` 信号。

---

## 二、完整渲染循环（稳定运行时）

主循环架构是**生产者-消费者帧同步**：渲染线程控制帧节奏，求解器线程在每帧中计算 `stepsPerFrame` 步仿真并写入双缓冲，两者通过 `std::condition_variable` 同步。

### 2.1 主线程等待求解器完成

```cpp
if (g_solverState == RUNNING)
    g_solverCV.wait(lock, [] { return g_solverState != RUNNING; });
hasNewResults = (g_solverState == DONE);
if (hasNewResults) g_solverState = IDLE;
```

首帧 `g_solverState == IDLE`，直接跳过等待。

### 2.2 安全区域（求解器不运行）

**延迟键盘操作处理**：
```cpp
if (g_resetRequested.exchange(false)) {
    solver.reset(params);
    params.t_current = 0; params.step = 0;
}
```

**消费求解器帧结果**（仅当 `hasNewResults`）：
```
renderer.submitField()
  → cudaGraphicsUnmapResources(PBO[writeIndex_])   // 解除 CUDA 映射
  → glTexSubImage2D(PBO → fieldTexture_)           // GPU 内部 DMA 传输
  → writeIndex_ = 1 - writeIndex_                  // 切换写入索引
  → mapFieldForWriting()                            // 预映射新 PBO，返回下帧写入指针

renderer.submitVectors(vectorVertexCount)            // 类似 PBO，对 VBO 做同样的 unmap→swap→remap
renderer.prepareVectorRender()                       // 快照 vectorRenderReadIndex_ = 1 - vectorWriteIndex_
cachedMaxTemp = g_solverResults.maxTemp
cachedMaxMach = g_solverResults.maxMach
```

**ImGui UI 帧**：`renderUI()` 纯 ImGui 调用，收集用户输入（不直接改变 GPU 状态），用户交互事件在本帧安全区域同步执行（见第三章）。

**设置场值范围**：根据 `currentField` 和用户调节的滑块值调用 `renderer.setFieldRange(minVal, maxVal, type)`，仅更新 `minVal_/maxVal_` 成员，渲染时传入 shader uniform。

**确保矢量 VBO 容量**（若启用矢量显示）：
```cpp
renderer.ensureVectorVBOCapacity(numArrowsX * numArrowsY * VERTICES_PER_ARROW)
// 若容量不足则：unmap → 注销 CUDA 资源 → glBufferData 重新分配 → 注册 → remap
```

### 2.3 信号求解器开始计算

```cpp
std::lock_guard lock(g_solverMutex);
g_solverState = SolverState::RUNNING;
g_solverCV.notify_one();
```

求解器线程被唤醒，开始异步执行。

### 2.4 并行区域：GL 渲染当前帧

此时求解器线程正在 GPU 上写 PBO[writeIndex] 和 VBO[vectorWriteIndex]，GL 线程读 `fieldTexture_`（上一帧已上传）和 VBO[vectorRenderReadIndex_]（上一帧数据），两者访问不同资源，完全并行。

**`renderer.render(params)` 展开**：

```
glClear(COLOR_BUFFER_BIT)

// 第一层：物理场
glUseProgram(shaderProgram_)
glActiveTexture(GL_TEXTURE0) + glBindTexture(fieldTexture_)     // 物理量
glActiveTexture(GL_TEXTURE1) + glBindTexture(colormapTexture_)  // 色图
glActiveTexture(GL_TEXTURE2) + glBindTexture(cellTypeTexture_)  // 网格类型
glUniform1f(loc_minVal_, minVal_)
glUniform1f(loc_maxVal_, maxVal_)
glBindVertexArray(VAO_) + glDrawArrays(GL_TRIANGLES, 0, 6)      // 全屏四边形

// 第二层：矢量箭头（如果启用，使用 readIndex 的 VBO）
if (showVectors_ && vectorRenderVertexCount_ > 0):
    glUseProgram(vectorShaderProgram_)
    glBindBuffer(GL_ARRAY_BUFFER, vectorVBO_[vectorRenderReadIndex_])
    glVertexAttribPointer(0, 2, float, stride=5) // xy
    glVertexAttribPointer(1, 3, float, offset=2) // rgb
    glDrawArrays(GL_LINES, 0, vectorRenderVertexCount_)
```

片元着色器内联逻辑（GPU）：

```glsl
float value    = texture(fieldTexture, TexCoord).r;
float cellType = texture(cellTypeTexture, TexCoord).r;
if (cellType in (0.5, 2.5)) { FragColor = vec4(0.3, 0.3, 0.3, 1.0); return; }
float norm = clamp((value - minVal) / (maxVal - minVal + 1e-4), 0, 1);
FragColor = vec4(texture(colormapTexture, norm).rgb, 1.0);
```

ImGui 渲染：`ImGui::Render()` + `ImGui_ImplOpenGL3_RenderDrawData()`。

`glfwSwapBuffers(window)` 交换前后缓冲区，完成当前帧呈现。

### 2.5 求解器线程（与 2.4 并行执行）

**步骤 1：`stepsPerFrame` 次仿真推进**

每次 `solver.step(params)`，以无粘性欧拉模式为例：

```
launchComputeFluxesKernel(rho, u, v, p, cell_type → flux_*_x/y)
```

`computeFluxesKernel` 对每个网格 `(i,j)` 在 `i+1/2` 和 `j+1/2` 界面处计算通量：
- 固体/Ghost 界面：通量置零（壁面不通质量、动量，仅有压力项）。
- 流体界面，邻近固体或低密度区：降级为一阶（直接取网格中心值）+ HLL 求解器（更稳健）。
- 正常流体界面：MUSCL 二阶重构（minmod 限制器）+ HLLC 求解器（含接触间断）。
- 内能通量单独用迎风格式：$f_{\rho e} = \rho e \cdot u_{face}$（双能量法）。

```
launchUpdateKernel(rho, rho_u, rho_v, E, rho_e | u, v, p | flux_* → rho_new, rho_u_new, rho_v_new, E_new, rho_e_new)
```

`updateKernel` 对每个流体网格执行：

1. 有限体积法散度：$\Delta F_x = (F_{i+1/2} - F_{i-1/2})/\Delta x$，Y 方向同理。
2. 内能源项：$S_{\rho e} = -p \cdot \nabla \cdot \mathbf{v}$（中心差分 $\nabla \cdot \mathbf{v}$）。
3. 欧拉前向积分：$U^{n+1} = U^n - \Delta t \cdot \nabla \cdot F$。
4. 速度超限截断（`MAX_VELOCITY_LIMIT = 5000 m/s`）。
5. **双能量同步**：计算 $\eta = \rho e / E_{total}$；若 $\eta > 0.1$（热能显著）用 $E-KE$ 法；否则（高速动能主导）用独立追踪的 $\rho e$ 法重构总能量，防止大数减小数失精度。

```
std::swap(d_rho_, d_rho_new_)   // 双缓冲指针交换，O(1) 无数据拷贝
...
launchApplyBoundaryConditionsKernel(...)
```

`applyBoundaryConditionsKernel` 按网格类型分支处理：

| 网格类型 | 处理方式 |
|---------|---------|
| `CELL_INFLOW` / `i==0` | 直接重写为来流守恒变量 |
| `CELL_OUTFLOW` / `i==nx-1` | 非反射特征边界：从 Riemann 不变量混合局部与来流值 |
| `j==0` 或 `j==ny-1` | Y 方向特征边界（同上，以 v 为主方向） |
| `CELL_SOLID` | 重写为来流内能状态，速度归零 |
| `CELL_GHOST` | Ghost Cell 法：①SDF 梯度求法向 ②8 邻域找最近流体格 ③按粘性/无粘性选镜像或滑移速度条件 ④按绝热/等温选温度条件 ⑤写入虚拟网格 |

```
launchComputePrimitivesKernel(守恒量 → u, v, p, T)
```

为下一步的 `computeStableTimeStep` 和可视化准备最新原始变量，避免重复计算。

**粘性模式（NS 方程，Strang 算子分裂）**：

```
computeViscousTermsKernel(u, v, T → mu, tau_xx/yy/xy, qx/qy)  // 半步粘性
diffusionStepKernel(dt/2)
computePrimitivesKernel(更新守恒量)
[计算通量 + 更新 + 交换] (对流全步)
computePrimitivesKernel
computeViscousTermsKernel
diffusionStepKernel(dt/2)
```

`computeViscousTermsKernel` 融合核函数内部（每格一次）：
1. Sutherland 公式：$\mu = \mu_{ref}(T/T_{ref})^{3/2}(T_{ref}+S)/(T+S)$，$k = \mu C_p / Pr$。
2. 速度梯度（中心差分，边界单侧）→ 应力张量 $\tau_{xx/yy/xy}$。
3. 温度梯度（共享同一组邻居索引）→ 热通量 $q_x = -k \partial T/\partial x$。

**步骤 2：写入 PBO（零拷贝）**

```cpp
float *devPtr = renderer.getMappedFieldPtr();  // 获取已映射 PBO[writeIndex] 的设备指针
solver.computeTemperatureToDevice(devPtr);     // 或 Pressure/Density/VelocityMag/Mach
```

`compute*ToDevice` 系列核函数直接从守恒变量 `d_rho_/d_rho_e_/d_rho_u_/d_rho_v_` 计算并写入 `devPtr`（即 PBO 的 CUDA 地址），无任何中间缓冲区。

**步骤 3：生成矢量箭头（零拷贝，写入 VBO）**

```cpp
float *devVertexData = renderer.getMappedVectorPtr();
solver.generateVectorArrows(devVertexData, vboCapacity, step, u_inf, maxArrowLength, ...)
```

`generateVectorArrowsKernel` 每线程负责一个采样格，按步长 `step` 稀疏采样：
- 跳过速度 < $10^{-6} u_\infty$ 的点。
- 速度归一化后乘 `maxArrowLength * ARROW_LENGTH_SCALE` 得箭头长度。
- 每箭头 8 个顶点（箭身 2 + 两条头部线各 2），通过 `atomicAdd(d_atomic_counter_, 8)` 原子分配写入位置。
- 格式：每顶点 5 个 float（`x, y, r, g, b`），颜色固定黑色（0,0,0）。

**步骤 4：统计归约（节流 0.25 秒）**

```cpp
if (elapsed >= STATS_THROTTLE_INTERVAL) {
    g_solverResults.maxTemp = solver.getMaxTemperature();
    g_solverResults.maxMach = solver.getMaxMach();
}
```

`getMaxTemperature()` → `launchComputeMaxTemperature(d_T_)` → `cub::DeviceReduce::Max(d_reduction_buffer_, ..., d_T_, d_reduction_output_, n)` → `cudaMemcpy(result)`。  
`getMaxMach()` 先用 `computeMachNumberKernel` 把马赫数写入 `d_scratch_`，再 CUB 归约。

**步骤 5：同步并通知**

```cpp
cudaDeviceSynchronize();
{lock} g_solverState = DONE;
g_solverCV.notify_one();
```

主线程下一帧会在安全区域消费 DONE 状态，执行 `submitField()`/`submitVectors()`。

---

## 三、用户配置调整

所有用户交互发生在主循环安全区域（求解器 IDLE 状态），`renderUI()` 中各分支的响应路径如下。

### 3.1 暂停/继续（Space 键或按钮）

仅切换 `params.paused` bool，不触发任何 CUDA 调用。  
- 暂停时：主循环跳过 `notify_one()`，改为调用 `updateVisualization()`（在主线程直接计算场到 PBO 并 submit，允许用户切换可视化模式看同一帧数据）。  
- 继续时：恢复正常的 `RUNNING` 信号流程。

### 3.2 来流条件调整（马赫数、温度、压强）

ImGui 滑块触发 `params.computeDerived()`：

```cpp
rho_inf = p_inf / (R_GAS * T_inf)
c_inf   = sqrt(GAMMA * R_GAS * T_inf)
u_inf   = mach * c_inf
dx      = domain_width / nx;  dy = domain_height / ny
obstacle_y = domain_height / 2
```

**仅修改 `params`，不触发任何 CUDA 调用**。新参数在下一帧求解器线程的 `solver.step(params)` 中自动生效（`params` 按引用传入）：`step()` 使用 `params.dt`（由 `computeStableTimeStep()` 提前计算）、`params.rho_inf/u_inf` 等写入边界条件。

### 3.3 障碍物位置/旋转变化（`obstacleChanged`）

```cpp
solver.updateObstacleGeometry(params)
```

调用 `updateSDFWithFixupKernel`：与 `computeSDFKernel` 不同，此核函数读取旧 `cell_type`：
- 从固体/Ghost 变为流体的格：填充来流守恒变量（避免流场出现真空）。
- 从流体变为固体/Ghost 的格：守恒变量保持，下一步边界条件核函数会正确覆盖。

之后：
```
launchApplyBoundaryConditionsKernel(新 SDF 和 cell_type)
launchComputePrimitivesKernel(守恒量 → 原始量)
cudaDeviceSynchronize()
solver.getCellTypes(h_cellTypes)
renderer.updateCellTypes(h_cellTypes, nx, ny)   // 重新上传 cellTypeTexture_
```

`updateCellTypes` 将 `uint8_t` 逐元素转为 `float` 后调用 `glTexImage2D` 全量上传（固体形状发生变化，必须全量刷新）。

### 3.4 障碍物形状变化或尺寸变化（`shapeChanged`）

```cpp
solver.reset(params);                           // 完整重置流场
solver.getCellTypes(h_cellTypes);
renderer.updateCellTypes(h_cellTypes, nx, ny);
params.t_current = 0; params.step = 0;
```

与位置变化路径不同，形状/大小改变必须重置流场（SDF 拓扑改变，无法只做局部修正）。

### 3.5 可视化物理量切换（温度/压强/密度/速度/马赫数）

```cpp
currentField = static_cast<FieldType>(fieldIdx);
```

仅更新枚举值，不触发 GPU 操作。下一帧求解器线程的步骤 2 中根据 `currentField` 分支调用对应的 `compute*ToDevice` 核函数写入 PBO。

### 3.6 矢量箭头开关 / 密度调整

```cpp
renderer.setShowVectors(showVectors);
renderer.setVectorDensity(vectorDensity);
```

仅更新 `Renderer` 成员。密度（步长）改变会触发下帧 `ensureVectorVBOCapacity()` 检查容量（所需顶点数变化）。

### 3.7 色图切换

```cpp
renderer.setColormap(static_cast<ColormapType>(currentColormap));
// → createColormapTexture()
// → generate*Colormap(colors) + glTexImage1D(colormapTexture_)
```

纯 GL 操作，立刻生效于下一帧渲染。

### 3.8 网格分辨率变化（"应用网格尺寸"按钮）

```cpp
params.nx = nx_ui; params.ny = ny_ui;
params.computeDerived();
initializeSimulation();              // 完整重初始化（分配显存 + 互操作缓冲区）
params.t_current = 0; params.step = 0;
```

`initializeSimulation()` 调用路径见第 1.5 节，包括：重新 `solver.initialize()`（释放旧显存、分配新显存、reset 流场），重新 `renderer.initCudaInterop(nx, ny)`（重建 PBO，`glTexImage2D` 调整纹理尺寸，预映射 PBO[0]）。

### 3.9 粘性模式切换

```cpp
solver.reset(params);
```

切换 `enable_viscosity` 后必须 reset，因为粘性模式下 `d_mu_` 需要重新初始化（`reset()` 内部调用 `launchComputeViscousTermsKernel` 填充 `d_mu_`）。

### 3.10 重置（R 键或按钮）

键盘回调中设置 `g_resetRequested = true`（原子写），主循环安全区域检测并执行：
```cpp
solver.reset(params);
params.t_current = 0; params.step = 0;
```

ImGui 按钮版直接调用（已在安全区域内）：
```cpp
solver.reset(params);
params.t_current = 0; params.step = 0;
```

---

## 四、程序退出

### 4.1 触发退出

用户按 ESC 或点击关闭按钮，`glfwWindowShouldClose()` 返回 `true`，主循环退出。

### 4.2 停止求解器线程

```cpp
{ lock } g_solverShouldStop = true;
g_solverCV.notify_one();
g_solverThread.join();
```

求解器线程在下次循环顶部的 `wait` 检测到 `g_solverShouldStop`，直接 `return`，线程结束。

### 4.3 资源释放

```
ImGui_ImplOpenGL3_Shutdown()
ImGui_ImplGlfw_Shutdown()
ImGui::DestroyContext()

renderer.cleanup()
  → glDeleteTextures × 3 (field, colormap, cellType)
  → glDeleteProgram × 2 (field, vector)
  → glDeleteVertexArrays + glDeleteBuffers (quad VAO/VBO)
  → glDeleteVertexArrays + glDeleteBuffers × 2 (vector VAO/VBO[2])
  → cleanupCudaInterop()
      → cudaGraphicsUnmapResources(已映射的 PBO/VBO)
      → cudaGraphicsUnregisterResource × 4 (PBO[2] + VBO[2])
      → glDeleteBuffers × 2 (PBO)

~CFDSolver() → freeMemory()
  → cudaFree × 30+ 个指针（守恒量×10 + 原始量×4 + 通量×10 + 粘性×6 + 辅助×多个）

glfwDestroyWindow(window)
glfwTerminate()
```

CUDA 资源必须在 GL 上下文销毁（`glfwDestroyWindow`）之前注销（`cudaGraphicsUnregisterResource`），`renderer.cleanup()` 在 `glfwDestroyWindow` 前调用，顺序正确。

---

## 附：双缓冲 PBO/VBO 状态机

在任意帧边界，PBO 和 VBO 各自的两个缓冲始终处于以下互斥状态之一：

```
PBO[writeIndex]  : 已 CUDA 映射，d_xxx_ptr 有效，等待 Solver 线程写入
PBO[1-writeIndex]: 未映射，已上传为 fieldTexture_，等待 GL 采样渲染

VBO[vectorWriteIndex]  : 已 CUDA 映射，d_vector_ptr 有效，等待 Solver 写入
VBO[1-vectorWriteIndex]: 未映射（或已 unmap），GL 从中绘制上一帧箭头
```

`submitField()` 原子地执行：unmap 当前写缓冲 → DMA 到纹理 → `writeIndex ^= 1` → map 新写缓冲。整个 swap 在 GL 线程安全区域完成，Solver 线程不持有任何锁，帧间不存在 CPU-CPU 竞争。
