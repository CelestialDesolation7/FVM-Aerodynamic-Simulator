# 渲染数据流技术文档

## 非零拷贝模式数据流

### 1. 初始化阶段

#### 1.1 主函数初始化渲染器

```cpp
// main.cpp: main() - line 931
if (!renderer.initialize(windowWidth, windowHeight))
{
    std::cerr << "[错误] 程序在初始化Renderer阶段失败并退出\n";
    return -1;
}
```

#### 1.2 渲染器创建OpenGL纹理对象

```cpp
// renderer.cpp: Renderer::initialize() - line 241
glGenTextures(1, &fieldTexture_);
// 功能：生成1个纹理对象，ID存储在fieldTexture_中

glBindTexture(GL_TEXTURE_2D, fieldTexture_);
// 功能：绑定纹理对象为当前活动的2D纹理
// 参数1：纹理目标类型（GL_TEXTURE_2D = 2D纹理）
// 参数2：纹理对象ID

glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
// 功能：设置纹理缩小时的过滤方式
// 参数1：纹理目标
// 参数2：参数名（GL_TEXTURE_MIN_FILTER = 缩小过滤器）
// 参数3：过滤方式（GL_LINEAR = 线性插值）

glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
// 功能：设置纹理放大时的过滤方式
// 参数3：GL_LINEAR = 线性插值，平滑效果

glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
// 功能：设置纹理S轴（横向）的包裹方式
// 参数2：GL_TEXTURE_WRAP_S = S轴包裹模式
// 参数3：GL_CLAMP_TO_EDGE = 边缘像素延伸

glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
// 功能：设置纹理T轴（纵向）的包裹方式
```

#### 1.3 渲染器创建网格类型纹理

```cpp
// renderer.cpp: Renderer::initialize() - line 249
glGenTextures(1, &cellTypeTexture_);
glBindTexture(GL_TEXTURE_2D, cellTypeTexture_);

glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
// 参数3：GL_NEAREST = 最近邻插值，用于离散数据（网格类型）

glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
```

#### 1.4 主函数初始化求解器和CPU缓冲区

```cpp
// main.cpp: initializeSimulation() - line 134
params.computeDerived();
resizeBuffers();  // 分配CPU端缓冲区
solver.initialize(params);
```

```cpp
// main.cpp: resizeBuffers() - line 123
size_t size = params.nx * params.ny;
h_temperature.resize(size);  // CPU端温度缓冲区
h_pressure.resize(size);     // CPU端压强缓冲区
h_density.resize(size);      // CPU端密度缓冲区
h_u.resize(size);            // CPU端速度u缓冲区
h_v.resize(size);            // CPU端速度v缓冲区
h_cellTypes.resize(size);    // CPU端网格类型缓冲区
```

#### 1.5 求解器分配GPU内存

```cpp
// solver.cu: CFDSolver::initialize() - line 2519
allocateMemory();
```

```cpp
// solver.cu: CFDSolver::allocateMemory() - line 2450
size_t size = _nx * _ny * sizeof(float);

cudaMalloc(&d_rho_, size);      // GPU端密度场
cudaMalloc(&d_rho_u_, size);    // GPU端x方向动量
cudaMalloc(&d_rho_v_, size);    // GPU端y方向动量
cudaMalloc(&d_E_, size);        // GPU端总能量
cudaMalloc(&d_rho_e_, size);    // GPU端内能
// ... 其他守恒变量和原始变量
cudaMalloc(&d_u_, size);        // GPU端速度u
cudaMalloc(&d_v_, size);        // GPU端速度v
cudaMalloc(&d_p_, size);        // GPU端压强
cudaMalloc(&d_T_, size);        // GPU端温度
```

#### 1.6 初始化网格类型数据

```cpp
// main.cpp: initializeSimulation() - line 140
solver.getCellTypes(h_cellTypes.data());
renderer.updateCellTypes(h_cellTypes.data(), params.nx, params.ny);
```

```cpp
// solver.cu: CFDSolver::getCellTypes() - line 2779
CUDA_CHECK(cudaMemcpy(host_types, d_cell_type_, 
                      _nx * _ny * sizeof(uint8_t), 
                      cudaMemcpyDeviceToHost));
// 功能：从GPU拷贝网格类型数据到CPU
// 参数1：目标地址（CPU）
// 参数2：源地址（GPU）
// 参数3：拷贝字节数
// 参数4：拷贝方向（DeviceToHost = GPU到CPU）
```

```cpp
// renderer.cpp: Renderer::updateCellTypes() - line 786
std::vector<float> typeData(nx * ny);
for (int i = 0; i < nx * ny; i++)
{
    typeData[i] = static_cast<float>(types[i]);  // uint8转float
}

glBindTexture(GL_TEXTURE_2D, cellTypeTexture_);
glTexImage2D(GL_TEXTURE_2D, 0, GL_R32F, nx, ny, 0, GL_RED, GL_FLOAT, typeData.data());
// 功能：分配并上传2D纹理数据
// 参数1：纹理目标
// 参数2：mipmap层级（0=基础层）
// 参数3：内部格式（GL_R32F = 32位浮点红色通道）
// 参数4：纹理宽度
// 参数5：纹理高度
// 参数6：边界宽度（历史遗留，必须为0）
// 参数7：数据格式（GL_RED = 单通道红色）
// 参数8：数据类型（GL_FLOAT = 浮点数）
// 参数9：数据指针（CPU内存）
```

### 2. 仿真循环 - 数据更新阶段

#### 2.1 主循环触发仿真步进

```cpp
// main.cpp: main() - line 961
if (!params.paused)
{
    for (int i = 0; i < stepsPerFrame; i++)
    {
        float dt = solver.computeStableTimeStep(params);
        params.dt = dt;
        solver.step(params);  // GPU端执行仿真
    }
}
```

#### 2.2 求解器在GPU上更新守恒变量

```cpp
// solver.cu: CFDSolver::step() - line 2697
// 1. 计算原始变量（压强、温度等）
launchComputePrimitivesKernel(d_rho_, d_rho_u_, d_rho_v_, d_E_, d_rho_e_,
                              d_u_, d_v_, d_p_, d_T_, _nx, _ny);

// 2. 计算通量
launchComputeFluxesKernel(...);

// 3. 更新守恒变量
launchUpdateKernel(...);

// 4. 应用边界条件
launchApplyBoundaryConditionsKernel(...);

// 5. 确保原始变量为最新（用于可视化）
if (!params.enable_viscosity)
{
    launchComputePrimitivesKernel(d_rho_, d_rho_u_, d_rho_v_, d_E_, d_rho_e_,
                                  d_u_, d_v_, d_p_, d_T_, _nx, _ny);
}
```

注：此时所有数据都在GPU端，CPU端缓冲区（h_temperature等）尚未更新。

#### 2.3 主循环触发可视化更新（非零拷贝模式）

```cpp
// main.cpp: main() - line 978
updateVisualization();
```

```cpp
// main.cpp: updateVisualization() - line 808
if (enableCudaInterop && cudaInteropInitialized)
{
    updateVisualizationInterop();  // 零拷贝路径
}
else
{
    updateVisualizationCPU();      // 非零拷贝路径（本节分析）
}
```

#### 2.4 从GPU拷贝数据到CPU

```cpp
// main.cpp: updateVisualizationCPU() - line 596
switch (currentField)
{
case FieldType::TEMPERATURE:
    solver.getTemperatureField(h_temperature.data());  // GPU → CPU
    fieldData = h_temperature.data();
    minVal = params.T_min;
    maxVal = params.T_max;
    break;
    
case FieldType::PRESSURE:
    solver.getPressureField(h_pressure.data());  // GPU → CPU
    fieldData = h_pressure.data();
    // ...
}
```

```cpp
// solver.cu: CFDSolver::getTemperatureField() - line 2750
CUDA_CHECK(cudaMemcpy(host_T, d_T_, _nx * _ny * sizeof(float), 
                      cudaMemcpyDeviceToHost));
// 功能：从GPU拷贝温度场到CPU
// 此时发生第一次PCIe总线传输：GPU → CPU
```

对于速度大小场，需要在CPU端计算：

```cpp
// main.cpp: updateVisualizationCPU() - line 622
case FieldType::VELOCITY_MAG:
{
    solver.getVelocityField(h_u.data(), h_v.data());  // GPU → CPU
    
    // CPU端计算速度大小
    for (int i = 0; i < params.nx * params.ny; i++)
    {
        h_temperature[i] = sqrtf(h_u[i] * h_u[i] + h_v[i] * h_v[i]);
    }
    fieldData = h_temperature.data();
    // ...
}
```

```cpp
// solver.cu: CFDSolver::getVelocityField() - line 2766
CUDA_CHECK(cudaMemcpy(host_u, d_u_, _nx * _ny * sizeof(float), 
                      cudaMemcpyDeviceToHost));
CUDA_CHECK(cudaMemcpy(host_v, d_v_, _nx * _ny * sizeof(float), 
                      cudaMemcpyDeviceToHost));
// 两次GPU → CPU传输
```

#### 2.5 从CPU上传数据到GPU纹理

```cpp
// main.cpp: updateVisualizationCPU() - line 664
renderer.updateFieldCPU(fieldData, params.nx, params.ny, minVal, maxVal, currentField);
```

```cpp
// renderer.cpp: Renderer::updateFieldCPU() - line 763
if (cudaInteropEnabled_)
{
    fprintf(stderr, "[警告] 零拷贝模式下调用了CPU数据传输路径\n");
}

nx_ = nx;
ny_ = ny;
minVal_ = minVal;
maxVal_ = maxVal;
fieldType_ = type;

glBindTexture(GL_TEXTURE_2D, fieldTexture_);
glTexImage2D(GL_TEXTURE_2D, 0, GL_R32F, nx, ny, 0, GL_RED, GL_FLOAT, data);
// 功能：上传纹理数据到GPU
// 参数9：data指针指向CPU内存中的浮点数组
// 此时发生第二次PCIe总线传输：CPU → GPU
```

**数据流总结（非零拷贝）：**
```
GPU内存(d_T_) 
    ↓ cudaMemcpy DeviceToHost
CPU内存(h_temperature) 
    ↓ glTexImage2D
GPU纹理内存(fieldTexture_)
```

### 3. 渲染阶段

#### 3.1 主循环触发渲染

```cpp
// main.cpp: main() - line 981
renderer.render(params);
```

#### 3.2 清空帧缓冲

```cpp
// renderer.cpp: Renderer::render() - line 820
glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
// 功能：设置清屏颜色为深灰色
// 参数：RGBA值（0-1范围）

glClear(GL_COLOR_BUFFER_BIT);
// 功能：清空颜色缓冲区
```

#### 3.3 绑定着色器和纹理

```cpp
// renderer.cpp: Renderer::render() - line 824
glUseProgram(shaderProgram_);
// 功能：激活着色器程序

// 绑定物理场纹理到纹理单元0
glActiveTexture(GL_TEXTURE0);
// 功能：激活纹理单元0
// OpenGL支持多个纹理单元（GL_TEXTURE0到GL_TEXTURE31）

glBindTexture(GL_TEXTURE_2D, fieldTexture_);
// 功能：将fieldTexture_绑定到当前活动的纹理单元

glUniform1i(glGetUniformLocation(shaderProgram_, "fieldTexture"), 0);
// 功能：设置着色器uniform变量
// glGetUniformLocation：获取uniform变量在着色器中的位置
// 参数1：着色器程序ID
// 参数2：变量名
// glUniform1i：设置整型uniform变量值
// 参数2：值为0，表示使用纹理单元0
```

#### 3.4 绑定色图和网格类型纹理

```cpp
// renderer.cpp: Renderer::render() - line 831
glActiveTexture(GL_TEXTURE1);
glBindTexture(GL_TEXTURE_1D, colormapTexture_);
glUniform1i(glGetUniformLocation(shaderProgram_, "colormapTexture"), 1);

glActiveTexture(GL_TEXTURE2);
glBindTexture(GL_TEXTURE_2D, cellTypeTexture_);
glUniform1i(glGetUniformLocation(shaderProgram_, "cellTypeTexture"), 2);
```

#### 3.5 传递归一化参数

```cpp
// renderer.cpp: Renderer::render() - line 842
glUniform1f(glGetUniformLocation(shaderProgram_, "minVal"), minVal_);
// 功能：设置浮点型uniform变量
// glUniform1f用于单个float值

glUniform1f(glGetUniformLocation(shaderProgram_, "maxVal"), maxVal_);
```

#### 3.6 绘制全屏四边形

```cpp
// renderer.cpp: Renderer::render() - line 846
glBindVertexArray(VAO_);
// 功能：绑定顶点数组对象
// VAO存储了顶点属性配置

glDrawArrays(GL_TRIANGLES, 0, 6);
// 功能：绘制图元
// 参数1：图元类型（GL_TRIANGLES = 三角形）
// 参数2：起始顶点索引
// 参数3：顶点数量（6个顶点 = 2个三角形 = 1个四边形）
```

**片元着色器执行流程：**

```glsl
// renderer.cpp: FIELD_FRAGMENT_SHADER - line 47
void main() {
    float value = texture(fieldTexture, TexCoord).r;
    // 从物理场纹理采样
    
    float cellType = texture(cellTypeTexture, TexCoord).r;
    // 从网格类型纹理采样
    
    if (cellType > 0.5 && cellType < 2.5) {
        FragColor = vec4(0.3, 0.3, 0.3, 1.0);  // 固体显示为灰色
        return;
    }
    
    float normalized = clamp((value - minVal) / (maxVal - minVal + 0.0001), 0.0, 1.0);
    // 归一化到[0,1]
    
    vec3 color = texture(colormapTexture, normalized).rgb;
    // 从色图查找颜色
    
    FragColor = vec4(color, 1.0);
}
```

### 4. 销毁阶段

#### 4.1 主函数退出前清理渲染器

```cpp
// main.cpp: main() - line 1011
renderer.cleanup();
```

#### 4.2 渲染器释放OpenGL资源

```cpp
// renderer.cpp: Renderer::cleanup() - line 274
if (fieldTexture_)
    glDeleteTextures(1, &fieldTexture_);
// 功能：删除纹理对象
// 参数1：删除数量
// 参数2：纹理ID数组指针

if (colormapTexture_)
    glDeleteTextures(1, &colormapTexture_);
if (cellTypeTexture_)
    glDeleteTextures(1, &cellTypeTexture_);

if (shaderProgram_)
    glDeleteProgram(shaderProgram_);
// 功能：删除着色器程序

if (VAO_)
    glDeleteVertexArrays(1, &VAO_);
// 功能：删除顶点数组对象

if (VBO_)
    glDeleteBuffers(1, &VBO_);
// 功能：删除顶点缓冲对象
```

#### 4.3 求解器析构释放GPU内存

```cpp
// solver.cu: CFDSolver::~CFDSolver() - line 2437
freeMemory();
```

```cpp
// solver.cu: CFDSolver::freeMemory() - line 2507
if (d_rho_) cudaFree(d_rho_);
if (d_rho_u_) cudaFree(d_rho_u_);
// ... 释放所有CUDA内存
```

---

## 零拷贝模式数据流

### 1. 初始化阶段

#### 1.1 前期初始化（与非零拷贝相同）

前面1.1到1.5节的初始化步骤完全相同，包括：
- 渲染器初始化
- 创建OpenGL纹理
- 分配CPU缓冲区
- 求解器分配GPU内存

#### 1.2 用户勾选"启用GPU零拷贝加速"

```cpp
// main.cpp: renderUI() - line 193
if (ImGui::Checkbox(u8"启用GPU零拷贝加速", &enableCudaInterop))
{
    if (enableCudaInterop && !cudaInteropInitialized)
    {
        if (renderer.initCudaInterop(params.nx, params.ny))
        {
            cudaInteropInitialized = true;
            std::cout << "[主程序] CUDA-OpenGL互操作已启用" << std::endl;
        }
    }
}
```

#### 1.3 初始化CUDA-OpenGL互操作

```cpp
// renderer.cpp: Renderer::initCudaInterop() - line 314
nx_ = nx;
ny_ = ny;
size_t bufferSize = nx * ny * sizeof(float);

// 创建两个PBO用于双缓冲
glGenBuffers(2, fieldPBO_);
// 功能：生成2个缓冲区对象
// PBO = Pixel Buffer Object（像素缓冲对象）
```

#### 1.4 为每个PBO分配内存并注册到CUDA

```cpp
// renderer.cpp: Renderer::initCudaInterop() - line 329
for (int i = 0; i < 2; i++)
{
    glBindBuffer(GL_PIXEL_UNPACK_BUFFER, fieldPBO_[i]);
    // 功能：绑定PBO为像素解包缓冲区
    // GL_PIXEL_UNPACK_BUFFER：用于上传纹理数据的缓冲区
    
    glBufferData(GL_PIXEL_UNPACK_BUFFER, bufferSize, nullptr, GL_DYNAMIC_DRAW);
    // 功能：分配并初始化缓冲区存储
    // 参数1：缓冲区目标
    // 参数2：字节大小
    // 参数3：初始数据指针（nullptr = 不初始化数据）
    // 参数4：使用提示（GL_DYNAMIC_DRAW = 数据会被频繁修改和使用）
    
    glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
    // 解绑PBO

    // 注册PBO为CUDA图形资源
    cudaError_t err = cudaGraphicsGLRegisterBuffer(
        &cudaPBOResource_[i],
        fieldPBO_[i],
        cudaGraphicsMapFlagsWriteDiscard
    );
    // 功能：将OpenGL缓冲区注册为CUDA可访问的资源
    // 参数1：输出CUDA资源句柄
    // 参数2：OpenGL缓冲区ID
    // 参数3：访问标志（WriteDiscard = CUDA只写入，丢弃原内容）
}
```

#### 1.5 调整纹理尺寸

```cpp
// renderer.cpp: Renderer::initCudaInterop() - line 360
glBindTexture(GL_TEXTURE_2D, fieldTexture_);
glTexImage2D(GL_TEXTURE_2D, 0, GL_R32F, nx, ny, 0, GL_RED, GL_FLOAT, nullptr);
// 功能：分配纹理内存（不上传数据）
// 参数9：nullptr表示只分配GPU内存，不传输数据

glBindTexture(GL_TEXTURE_2D, 0);

mappedSize_ = bufferSize;
writeIndex_ = 0;
cudaInteropEnabled_ = true;
```

**关键数据结构：**
- `fieldPBO_[2]`：两个OpenGL PBO ID
- `cudaPBOResource_[2]`：对应的CUDA资源句柄
- `writeIndex_`：当前写入的PBO索引（0或1）

**双缓冲机制：**
```
帧N：CUDA写入PBO[0]，OpenGL读取PBO[1]到纹理
帧N+1：CUDA写入PBO[1]，OpenGL读取PBO[0]到纹理
```

### 2. 仿真循环 - 数据更新阶段

#### 2.1 求解器执行仿真（与非零拷贝相同）

```cpp
// main.cpp: main() - line 966
solver.step(params);  // GPU端更新守恒变量
```

所有数据仍在GPU端（d_rho_, d_rho_u_, d_T_等）。

#### 2.2 主循环触发可视化更新（零拷贝模式）

```cpp
// main.cpp: updateVisualization() - line 808
if (enableCudaInterop && cudaInteropInitialized)
{
    updateVisualizationInterop();  // 零拷贝路径
}
```

#### 2.3 计算值域范围

```cpp
// main.cpp: updateVisualizationInterop() - line 672
switch (currentField)
{
case FieldType::TEMPERATURE:
    minVal = params.T_min;
    maxVal = params.T_max;
    break;
// ... 其他场类型
}
```

#### 2.4 设置渲染器参数

```cpp
// main.cpp: updateVisualizationInterop() - line 695
renderer.setFieldRange(minVal, maxVal, currentField);
```

```cpp
// renderer.cpp: Renderer::setFieldRange() - line 461
minVal_ = minVal;
maxVal_ = maxVal;
fieldType_ = type;
// 仅保存参数，无数据传输
```

#### 2.5 映射PBO获取GPU设备指针

```cpp
// main.cpp: updateVisualizationInterop() - line 698
float *devPtr = renderer.mapFieldTexture();
```

```cpp
// renderer.cpp: Renderer::mapFieldTexture() - line 397
if (!cudaInteropEnabled_ || !cudaPBOResource_[writeIndex_])
{
    return nullptr;
}

// 映射当前写入PBO
cudaError_t err = cudaGraphicsMapResources(1, &cudaPBOResource_[writeIndex_], 0);
// 功能：映射OpenGL资源供CUDA访问
// 参数1：资源数量
// 参数2：资源句柄数组
// 参数3：CUDA流（0 = 默认流）
// 此时PBO的GPU内存被锁定，CUDA可以直接访问

// 获取设备指针
float *devPtr = nullptr;
size_t size = 0;
err = cudaGraphicsResourceGetMappedPointer(
    reinterpret_cast<void **>(&devPtr), 
    &size, 
    cudaPBOResource_[writeIndex_]
);
// 功能：获取映射资源的GPU设备指针
// 参数1：输出设备指针
// 参数2：输出内存大小
// 参数3：CUDA资源句柄
// 返回的devPtr指向PBO在GPU上的内存地址

return devPtr;
```

**关键点：** `devPtr`是PBO在GPU上的内存地址，CUDA可以直接写入，无需CPU参与。

#### 2.6 直接从保守变量计算到PBO

```cpp
// main.cpp: updateVisualizationInterop() - line 707
switch (currentField)
{
case FieldType::TEMPERATURE:
    solver.computeTemperatureToDevice(devPtr);
    break;
// ...
}
```

##### 2.6.1 温度场计算

```cpp
// solver.cu: CFDSolver::computeTemperatureToDevice() - line 2880
dim3 block(16, 16);
dim3 grid((_nx + block.x - 1) / block.x, (_ny + block.y - 1) / block.y);
computeTemperatureDirectKernel<<<grid, block>>>(d_rho_, d_rho_e_, dev_dst, _nx, _ny);
CUDA_CHECK(cudaGetLastError());
```

```cpp
// solver.cu: computeTemperatureDirectKernel - line 2874
__global__ void computeTemperatureDirectKernel(
    const float *rho, const float *rho_e, float *T_out, int nx, int ny)
{
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    int j = blockIdx.y * blockDim.y + threadIdx.y;
    if (i >= nx || j >= ny) return;

    int idx = j * nx + i;
    float rho_val = rho[idx];
    float rho_e_val = rho_e[idx];
    
    // 从保守变量直接计算温度：T = (gamma-1)*e/R
    float e = rho_e_val / (rho_val + 1e-10f);
    T_out[idx] = (GAMMA - 1.0f) * e / R_GAS;
}
```

**数据流（温度场）：**
```
GPU: d_rho_, d_rho_e_ (求解器内存)
  ↓ 直接在GPU上计算（kernel）
GPU: devPtr (PBO内存)
```

##### 2.6.2 压强场计算

```cpp
// solver.cu: computePressureDirectKernel - line 2892
__global__ void computePressureDirectKernel(
    const float *rho, const float *rho_e, float *p_out, int nx, int ny)
{
    int idx = j * nx + i;
    float rho_e_val = rho_e[idx];
    
    // p = (gamma - 1) * rho_e
    p_out[idx] = (GAMMA - 1.0f) * rho_e_val;
}
```

##### 2.6.3 速度大小计算

```cpp
// solver.cu: computeVelocityMagDirectKernel - line 2905
__global__ void computeVelocityMagDirectKernel(
    const float *rho, const float *rho_u, const float *rho_v, 
    float *vmag_out, int nx, int ny)
{
    int idx = j * nx + i;
    float rho_val = rho[idx] + 1e-10f;
    float u = rho_u[idx] / rho_val;
    float v = rho_v[idx] / rho_val;
    
    vmag_out[idx] = sqrtf(u * u + v * v);
}
```

##### 2.6.4 马赫数计算

```cpp
// solver.cu: computeMachDirectKernel - line 2921
__global__ void computeMachDirectKernel(
    const float *rho, const float *rho_u, const float *rho_v, 
    const float *rho_e, float *mach_out, int nx, int ny)
{
    int idx = j * nx + i;
    float rho_val = rho[idx] + 1e-10f;
    
    // 计算速度
    float u = rho_u[idx] / rho_val;
    float v = rho_v[idx] / rho_val;
    float speed = sqrtf(u * u + v * v);
    
    // 计算温度和声速
    float e = rho_e[idx] / rho_val;
    float T = (GAMMA - 1.0f) * e / R_GAS;
    float c = sqrtf(GAMMA * R_GAS * T);
    
    mach_out[idx] = speed / (c + 1e-10f);
}
```

**性能优势：** 所有计算直接在GPU上完成，结果直接写入PBO，无任何CPU-GPU或GPU-GPU拷贝。

#### 2.7 取消映射PBO并交换缓冲区

```cpp
// main.cpp: updateVisualizationInterop() - line 726
renderer.unmapFieldTexture();
```

```cpp
// renderer.cpp: Renderer::unmapFieldTexture() - line 427
if (!cudaPBOResource_[writeIndex_])
    return;

// 取消当前写入PBO的CUDA映射
cudaGraphicsUnmapResources(1, &cudaPBOResource_[writeIndex_], 0);
// 功能：取消映射OpenGL资源
// 此时PBO被解锁，OpenGL可以访问CUDA写入的数据

// 交换缓冲区索引
int readIndex = writeIndex_;
writeIndex_ = 1 - writeIndex_;
// 下一帧CUDA将写入另一个PBO

// 将刚写入完成的PBO数据传输到纹理
glBindBuffer(GL_PIXEL_UNPACK_BUFFER, fieldPBO_[readIndex]);
// 功能：绑定读取PBO

glBindTexture(GL_TEXTURE_2D, fieldTexture_);

glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, nx_, ny_, GL_RED, GL_FLOAT, nullptr);
// 功能：更新纹理子区域
// 参数1：纹理目标
// 参数2：mipmap层级
// 参数3：X偏移
// 参数4：Y偏移
// 参数5：宽度
// 参数6：高度
// 参数7：数据格式
// 参数8：数据类型
// 参数9：nullptr表示从当前绑定的PBO读取数据
// 此操作在GPU内部完成，从PBO拷贝到纹理，无CPU参与

glBindTexture(GL_TEXTURE_2D, 0);
glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
```

**双缓冲机制详解：**

```
时刻T（帧N）：
  - writeIndex_ = 0
  - CUDA写入PBO[0]
  - OpenGL从PBO[1]读取到纹理（上一帧的数据）
  
unmapFieldTexture()执行：
  - readIndex = 0
  - writeIndex_ = 1
  - OpenGL从PBO[0]读取到纹理（当前帧数据）

时刻T+1（帧N+1）：
  - writeIndex_ = 1
  - CUDA写入PBO[1]
  - OpenGL从PBO[0]读取到纹理（上一帧数据）
```

**完整数据流（零拷贝）：**
```
GPU: d_rho_, d_rho_e_ (求解器内存)
  ↓ CUDA kernel直接计算
GPU: PBO[writeIndex] (OpenGL缓冲区，被CUDA映射)
  ↓ glTexSubImage2D (GPU内部传输)
GPU: fieldTexture_ (OpenGL纹理)
  ↓ OpenGL渲染管线
屏幕
```

**性能特征：**
- 零CPU参与
- 零PCIe总线传输
- 一次GPU kernel计算
- 一次GPU内部拷贝（PBO到纹理，带宽极高）

### 3. 渲染阶段

#### 3.1 渲染流程（与非零拷贝完全相同）

零拷贝模式的渲染阶段与非零拷贝完全相同，因为数据已经在GPU纹理中：

```cpp
// renderer.cpp: Renderer::render() - line 820
glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
glClear(GL_COLOR_BUFFER_BIT);

glUseProgram(shaderProgram_);

glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, fieldTexture_);  // 使用已更新的纹理
glUniform1i(glGetUniformLocation(shaderProgram_, "fieldTexture"), 0);

// ... 绑定其他纹理和参数

glBindVertexArray(VAO_);
glDrawArrays(GL_TRIANGLES, 0, 6);
```

### 4. 销毁阶段

#### 4.1 清理CUDA互操作资源

```cpp
// renderer.cpp: Renderer::cleanupCudaInterop() - line 376
for (int i = 0; i < 2; i++)
{
    if (cudaPBOResource_[i])
    {
        cudaGraphicsUnregisterResource(cudaPBOResource_[i]);
        // 功能：注销CUDA图形资源
        // 释放CUDA对OpenGL缓冲区的访问权限
        
        cudaPBOResource_[i] = nullptr;
    }
}

if (fieldPBO_[0] || fieldPBO_[1])
{
    glDeleteBuffers(2, fieldPBO_);
    // 功能：删除PBO对象
    
    fieldPBO_[0] = fieldPBO_[1] = 0;
}

cudaInteropEnabled_ = false;
mappedSize_ = 0;
writeIndex_ = 0;
```

#### 4.2 清理其他资源（与非零拷贝相同）

```cpp
// renderer.cpp: Renderer::cleanup() - line 274
if (fieldTexture_)
    glDeleteTextures(1, &fieldTexture_);
if (colormapTexture_)
    glDeleteTextures(1, &colormapTexture_);
// ... 删除其他OpenGL对象
```

---

## 关键差异对比

### 数据传输次数

**非零拷贝（每帧）：**
1. GPU → CPU：cudaMemcpy (DeviceToHost) - PCIe传输
2. CPU → GPU：glTexImage2D - PCIe传输
总计：2次PCIe总线传输

**零拷贝（每帧）：**
1. GPU kernel计算到PBO - GPU内部
2. PBO → 纹理 - GPU内部传输（glTexSubImage2D）
总计：0次PCIe总线传输

### 内存拷贝

**非零拷贝：**
- 1次GPU→CPU拷贝（d_T_ → h_temperature）
- 1次CPU→GPU拷贝（h_temperature → fieldTexture_）
- CPU端可能有额外计算（如速度大小）

**零拷贝：**
- 0次CPU参与的拷贝
- 1次GPU内部拷贝（PBO → 纹理，带宽>1TB/s）
- 所有计算在GPU上完成

### 性能差异（1024×512网格）

**非零拷贝：**
- 数据传输：~2-3ms（PCIe Gen3 x16）
- CPU计算：~0.1-0.5ms
- 总开销：~2.5-3.5ms

**零拷贝：**
- CUDA kernel：~0.1-0.2ms
- PBO→纹理：~0.05-0.1ms
- 总开销：~0.15-0.3ms

**加速比：10-20倍**

### 同步开销

**非零拷贝：**
- cudaMemcpy是同步操作，必须等待GPU完成所有前序任务
- CPU在等待传输期间被阻塞

**零拷贝：**
- CUDA kernel异步执行
- cudaGraphicsMapResources会同步，但仅同步映射操作
- CPU几乎无等待

### 内存占用

**非零拷贝：**
- GPU内存：守恒变量 + 原始变量 + 纹理
- CPU内存：h_temperature等缓冲区（nx×ny×sizeof(float)）
- 总额外开销：约4-8MB（1024×512网格）

**零拷贝：**
- GPU内存：守恒变量 + 原始变量 + 纹理 + 2个PBO
- CPU内存：h_temperature等缓冲区（仍需保留，用于矢量显示）
- 总额外开销：约8MB（2个PBO）

---

## UI可视化参数控制流程

### 1. 色图类型选择

#### 1.1 用户在UI中选择色图

```cpp
// main.cpp: renderUI() - line 449
if (ImGui::Combo(u8"色图", &currentColormap, colormapNames, 5))
// ImGui::Combo功能：创建下拉选择框
// 参数1：标签文本
// 参数2：当前选中项的索引（引用，会被修改）
// 参数3：选项名称数组
// 参数4：选项数量
// 返回值：用户是否改变了选择
{
    renderer.setColormap(static_cast<ColormapType>(currentColormap));
}
```

```cpp
// main.cpp: 全局变量 - line 53
const char *colormapNames[] = {"Jet", "Hot", "Plasma", "Inferno", "Viridis"};
int currentColormap = 0;  // 当前选中的色图索引
```

#### 1.2 渲染器接收色图切换请求

```cpp
// renderer.cpp: Renderer::setColormap() - line 750
void Renderer::setColormap(ColormapType cmap)
{
    if (colormap_ != cmap)  // 仅在色图改变时更新
    {
        colormap_ = cmap;
        createColormapTexture();  // 重新生成色图纹理
    }
}
```

#### 1.3 生成色图纹理数据

```cpp
// renderer.cpp: Renderer::createColormapTexture() - line 579
void Renderer::createColormapTexture()
{
    std::vector<float> colors;  // CPU端色图数据缓冲区

    // 根据当前选中的色图类型生成对应的颜色数据
    switch (colormap_)
    {
    case ColormapType::JET:
        generateJetColormap(colors);      // 生成256×3的RGB数据
        break;
    case ColormapType::HOT:
        generateHotColormap(colors);
        break;
    // ... 其他色图类型
    }

    if (colormapTexture_ == 0)
    {
        glGenTextures(1, &colormapTexture_);
        // 功能：生成纹理对象（仅首次调用时）
    }

    glBindTexture(GL_TEXTURE_1D, colormapTexture_);
    // 功能：绑定1D纹理对象
    // 1D纹理：只有一维（宽度），用于查找表
    
    glTexImage1D(GL_TEXTURE_1D, 0, GL_RGB32F, 256, 0, GL_RGB, GL_FLOAT, colors.data());
    // 功能：上传1D纹理数据
    // 参数1：纹理目标（GL_TEXTURE_1D = 1D纹理）
    // 参数2：mipmap层级
    // 参数3：内部格式（GL_RGB32F = 每通道32位浮点，RGB三通道）
    // 参数4：纹理宽度（256个颜色）
    // 参数5：边界宽度（历史遗留，必须为0）
    // 参数6：数据格式（GL_RGB = RGB三通道）
    // 参数7：数据类型（GL_FLOAT = 浮点数）
    // 参数8：数据指针（CPU内存中的颜色数组）
    
    glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    // 线性插值，平滑过渡
    
    glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    
    glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    // S轴包裹：边缘延伸（防止查找表越界）
}
```

#### 1.4 色图生成示例：Jet色图

```cpp
// renderer.cpp: Renderer::generateJetColormap() - line 620
void Renderer::generateJetColormap(std::vector<float> &colors)
{
    colors.resize(256 * 3);  // 256个颜色 × 3个通道（RGB）

    for (int i = 0; i < 256; i++)
    {
        float t = i / 255.0f;  // 归一化到[0,1]
        float r, g, b;

        // Jet色图：蓝 -> 青 -> 绿 -> 黄 -> 红
        if (t < 0.125f)
        {
            r = 0.0f;
            g = 0.0f;
            b = 0.5f + 4.0f * t;  // 从深蓝到亮蓝
        }
        else if (t < 0.375f)
        {
            r = 0.0f;
            g = 4.0f * (t - 0.125f);  // 从蓝到青
            b = 1.0f;
        }
        // ... 其他颜色段
        
        colors[i * 3 + 0] = r;  // 红色通道
        colors[i * 3 + 1] = g;  // 绿色通道
        colors[i * 3 + 2] = b;  // 蓝色通道
    }
}
```

#### 1.5 片元着色器使用色图纹理

```cpp
// renderer.cpp: FIELD_FRAGMENT_SHADER - line 47
in vec2 TexCoord;
out vec4 FragColor;

uniform sampler2D fieldTexture;       // 物理场数据纹理
uniform sampler1D colormapTexture;    // 色图纹理（1D查找表）
uniform sampler2D cellTypeTexture;
uniform float minVal;
uniform float maxVal;

void main() {
    float value = texture(fieldTexture, TexCoord).r;  // 采样物理量
    
    // 归一化到[0,1]
    float normalized = clamp((value - minVal) / (maxVal - minVal + 0.0001), 0.0, 1.0);
    
    // 从1D色图纹理查找颜色
    vec3 color = texture(colormapTexture, normalized).rgb;
    // normalized作为1D纹理坐标，范围[0,1]
    // 返回对应的RGB颜色
    
    FragColor = vec4(color, 1.0);
}
```

**数据流（色图）：**
```
UI选择
  ↓
main.cpp: currentColormap变量
  ↓
renderer.setColormap()
  ↓
CPU: generateXXXColormap() 生成256×3的RGB数组
  ↓
glTexImage1D: CPU → GPU上传色图纹理
  ↓
片元着色器: texture(colormapTexture, normalized) 查找颜色
```

### 2. 色图范围调整

#### 2.1 用户调整范围滑块

```cpp
// main.cpp: renderUI() - line 458
switch (currentField)
{
case FieldType::TEMPERATURE:
    ImGui::SliderFloat(u8"温度下限 (K)", &params.T_min, 100.0f, 500.0f);
    // ImGui::SliderFloat功能：创建浮点数滑块
    // 参数1：标签文本
    // 参数2：绑定的变量指针（会被修改）
    // 参数3：最小值
    // 参数4：最大值
    
    ImGui::SliderFloat(u8"温度上限 (K)", &params.T_max, 300.0f, 2000.0f);
    break;

case FieldType::PRESSURE:
    ImGui::SliderFloat(u8"压强下限 (倍数)", &p_min_ratio, 0.1f, 1.0f);
    ImGui::SliderFloat(u8"压强上限 (倍数)", &p_max_ratio, 1.0f, 10.0f);
    ImGui::Text(u8"实际范围: %.0f - %.0f Pa", 
                params.p_inf * p_min_ratio, 
                params.p_inf * p_max_ratio);
    // 显示实际的物理单位范围
    break;

case FieldType::VELOCITY_MAG:
    ImGui::SliderFloat(u8"速度上限 (倍数)", &v_max_ratio, 0.5f, 3.0f);
    ImGui::Text(u8"实际范围: 0 - %.1f m/s", params.u_inf * v_max_ratio);
    break;

// ... 其他物理量
}
```

```cpp
// main.cpp: 全局变量 - line 57
float p_min_ratio = 0.5f;      // 压强下限倍数（相对于来流压强）
float p_max_ratio = 5.0f;      // 压强上限倍数
float rho_min_ratio = 0.5f;    // 密度下限倍数
float rho_max_ratio = 5.0f;    // 密度上限倍数
float v_max_ratio = 1.5f;      // 速度上限倍数（相对于来流速度）
float mach_max_ratio = 1.5f;   // 马赫数上限倍数
```

#### 2.2 范围参数传递到可视化更新（非零拷贝）

```cpp
// main.cpp: updateVisualizationCPU() - line 596
switch (currentField)
{
case FieldType::TEMPERATURE:
    solver.getTemperatureField(h_temperature.data());
    fieldData = h_temperature.data();
    minVal = params.T_min;      // 直接使用UI设置的值
    maxVal = params.T_max;
    break;

case FieldType::PRESSURE:
    solver.getPressureField(h_pressure.data());
    fieldData = h_pressure.data();
    minVal = params.p_inf * p_min_ratio;  // 计算实际范围
    maxVal = params.p_inf * p_max_ratio;
    break;

case FieldType::VELOCITY_MAG:
    // ...
    minVal = 0.0f;
    maxVal = params.u_inf * v_max_ratio;  // 使用UI设置的倍数
    break;
}

// 传递给渲染器
renderer.updateFieldCPU(fieldData, params.nx, params.ny, minVal, maxVal, currentField);
```

```cpp
// renderer.cpp: Renderer::updateFieldCPU() - line 763
void Renderer::updateFieldCPU(const float *data, int nx, int ny,
                              float minVal, float maxVal, FieldType type)
{
    nx_ = nx;
    ny_ = ny;
    minVal_ = minVal;  // 保存到成员变量
    maxVal_ = maxVal;
    fieldType_ = type;

    glBindTexture(GL_TEXTURE_2D, fieldTexture_);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_R32F, nx, ny, 0, GL_RED, GL_FLOAT, data);
    // 上传物理场数据，但minVal和maxVal仅保存在CPU端
}
```

#### 2.3 范围参数传递到可视化更新（零拷贝）

```cpp
// main.cpp: updateVisualizationInterop() - line 672
switch (currentField)
{
case FieldType::TEMPERATURE:
    minVal = params.T_min;
    maxVal = params.T_max;
    break;
case FieldType::PRESSURE:
    minVal = params.p_inf * p_min_ratio;
    maxVal = params.p_inf * p_max_ratio;
    break;
// ... 其他场
}

renderer.setFieldRange(minVal, maxVal, currentField);
// 仅设置参数，无数据传输
```

```cpp
// renderer.cpp: Renderer::setFieldRange() - line 461
void Renderer::setFieldRange(float minVal, float maxVal, FieldType type)
{
    minVal_ = minVal;
    maxVal_ = maxVal;
    fieldType_ = type;
}
```

#### 2.4 范围参数在渲染时使用

```cpp
// renderer.cpp: Renderer::render() - line 842
glUniform1f(glGetUniformLocation(shaderProgram_, "minVal"), minVal_);
// 功能：将minVal_传递给片元着色器的uniform变量
// glGetUniformLocation：获取uniform变量在着色器中的位置ID
// 参数1：着色器程序
// 参数2：变量名（必须与着色器中声明一致）
// glUniform1f：设置单个浮点uniform变量
// 参数2：变量值

glUniform1f(glGetUniformLocation(shaderProgram_, "maxVal"), maxVal_);
```

#### 2.5 片元着色器使用范围参数归一化

```cpp
// renderer.cpp: FIELD_FRAGMENT_SHADER - line 47
uniform float minVal;  // 来自CPU端的uniform变量
uniform float maxVal;

void main() {
    float value = texture(fieldTexture, TexCoord).r;  // 原始物理量值
    
    // 归一化：将[minVal, maxVal]映射到[0, 1]
    float normalized = clamp((value - minVal) / (maxVal - minVal + 0.0001), 0.0, 1.0);
    // clamp函数：限制在[0,1]范围内
    // +0.0001：防止除零
    
    // 使用归一化值查找色图
    vec3 color = texture(colormapTexture, normalized).rgb;
    FragColor = vec4(color, 1.0);
}
```

**范围参数作用机制：**
```
用户移动滑块
  ↓
UI: 修改全局变量（p_min_ratio等）
  ↓
updateVisualization: 计算实际范围（minVal, maxVal）
  ↓
renderer: 保存到成员变量（minVal_, maxVal_）
  ↓
render(): 通过glUniform1f传递给GPU
  ↓
片元着色器: 使用minVal/maxVal归一化物理量
  ↓
归一化值查找色图纹理
  ↓
最终颜色输出
```

**性能特征：**
- 范围调整无需重新传输物理场数据
- 仅需更新2个uniform变量（极低开销，<1μs）
- 片元着色器实时重新归一化和着色
- 用户可以实时调整范围查看不同细节

### 3. 速度矢量显示控制

#### 3.1 用户勾选"显示速度矢量"

```cpp
// main.cpp: renderUI() - line 486
if (currentField == FieldType::VELOCITY_MAG)  // 仅在速度场模式下可用
{
    bool showVectors = renderer.getShowVectors();  // 获取当前状态
    if (ImGui::Checkbox(u8"显示速度矢量", &showVectors))
    // ImGui::Checkbox功能：创建复选框
    // 参数1：标签文本
    // 参数2：布尔变量指针（会被修改）
    // 返回值：用户是否改变了状态
    {
        renderer.setShowVectors(showVectors);  // 设置新状态
    }
}
else
{
    renderer.setShowVectors(false);  // 其他模式自动关闭
}
```

```cpp
// renderer.h: Renderer类 - line 125
void setShowVectors(bool show) { showVectors_ = show; }
bool getShowVectors() const { return showVectors_; }
```

```cpp
// renderer.h: 成员变量 - line 213
bool showVectors_ = false;  // 是否显示速度矢量
```

#### 3.2 速度数据传输到渲染器（非零拷贝）

```cpp
// main.cpp: updateVisualizationCPU() - line 622
case FieldType::VELOCITY_MAG:
{
    solver.getVelocityField(h_u.data(), h_v.data());  // GPU → CPU
    
    // CPU端计算速度大小
    for (int i = 0; i < params.nx * params.ny; i++)
    {
        h_temperature[i] = sqrtf(h_u[i] * h_u[i] + h_v[i] * h_v[i]);
    }
    fieldData = h_temperature.data();
    
    // 更新速度场数据用于矢量可视化
    renderer.updateVelocityField(h_u.data(), h_v.data(), params.nx, params.ny, params.u_inf);
    // 将u,v分量传递给渲染器，存储在CPU端
    break;
}
```

```cpp
// renderer.cpp: Renderer::updateVelocityField() - line 800
void Renderer::updateVelocityField(const float *u, const float *v, int nx, int ny, float u_inf)
{
    if (nx <= 0 || ny <= 0)
        return;

    size_t size = static_cast<size_t>(nx) * ny;
    velocityU_.resize(size);  // CPU端速度u缓冲区
    velocityV_.resize(size);  // CPU端速度v缓冲区

    std::copy(u, u + size, velocityU_.begin());  // 拷贝到成员变量
    std::copy(v, v + size, velocityV_.begin());

    u_inf_ = u_inf;  // 来流速度，用于归一化箭头长度
}
```

```cpp
// renderer.h: 成员变量 - line 217
std::vector<float> velocityU_;  // 速度u分量（CPU端）
std::vector<float> velocityV_;  // 速度v分量（CPU端）
float u_inf_ = 1.0f;            // 来流速度
```

#### 3.3 速度数据传输到渲染器（零拷贝）

```cpp
// main.cpp: updateVisualizationInterop() - line 707
case FieldType::VELOCITY_MAG:
    solver.computeVelocityMagToDevice(devPtr);  // 速度大小直接写入PBO
    
    // 速度矢量箭头仍需CPU数据
    if (renderer.getShowVectors())
    {
        solver.getVelocityField(h_u.data(), h_v.data());  // GPU → CPU
        renderer.updateVelocityField(h_u.data(), h_v.data(), params.nx, params.ny, params.u_inf);
    }
    break;
```

**注意：** 零拷贝模式下，速度矢量显示是唯一需要GPU→CPU传输的功能。

#### 3.4 渲染矢量箭头

```cpp
// renderer.cpp: Renderer::render() - line 979
// 第三层：渲染速度矢量箭头
if (showVectors_ && nx_ > 0 && ny_ > 0 && !velocityU_.empty() && !velocityV_.empty())
// 条件：矢量显示开启 + 网格有效 + 速度数据存在
{
    glUseProgram(vectorShaderProgram_);
    // 使用专门的矢量着色器

    std::vector<float> vectorVerts;  // CPU端生成顶点数据
    
    // 箭头参数
    const float arrowHeadAngle = 0.5f;   // 箭头头部张角
    const float arrowHeadLength = 0.3f;  // 箭头头部长度比例
    
    int step = vectorDensity_;  // 采样间隔（从UI设置）
    
    // 计算箭头最大长度
    float cellWidth = 2.0f / nx_;
    float cellHeight = 2.0f / ny_;
    float maxArrowLength = std::min(cellWidth, cellHeight) * (step * 0.8f);
    
    // 遍历网格，每隔step个格子绘制一个箭头
    for (int j = step / 2; j < ny_; j += step)
    {
        for (int i = step / 2; i < nx_; i += step)
        {
            int idx = j * nx_ + i;
            
            // 获取该点的速度分量
            float u = velocityU_[idx];
            float v = velocityV_[idx];
            
            // 计算速度大小
            float speed = sqrtf(u * u + v * v);
            if (speed < 1e-6f * u_inf_)
                continue;  // 跳过静止点
            
            // 归一化速度（用于调整箭头长度）
            float normalizedSpeed = std::min(speed / (u_inf_ * 1.5f), 1.0f);
            
            // 计算箭头起点（NDC坐标系，范围[-1,1]）
            float startX = (float)i / nx_ * 2.0f - 1.0f;
            float startY = (float)j / ny_ * 2.0f - 1.0f;
            
            // 计算箭头方向和长度
            float dirX = u / speed;  // 单位方向向量
            float dirY = v / speed;
            float arrowLength = maxArrowLength * normalizedSpeed;
            
            // 箭头终点
            float endX = startX + dirX * arrowLength;
            float endY = startY + dirY * arrowLength;
            
            // 箭身：两个顶点
            vectorVerts.insert(vectorVerts.end(), 
                {startX, startY, 0.0f, 0.0f, 0.0f});  // 起点 + 黑色
            vectorVerts.insert(vectorVerts.end(), 
                {endX, endY, 0.0f, 0.0f, 0.0f});      // 终点 + 黑色
            
            // 箭头头部：计算两个侧边顶点
            float headLen = arrowLength * arrowHeadLength;
            float cosA = cosf(arrowHeadAngle);
            float sinA = sinf(arrowHeadAngle);
            
            // 旋转计算头部顶点
            float head1X = endX - headLen * (dirX * cosA - dirY * sinA);
            float head1Y = endY - headLen * (dirX * sinA + dirY * cosA);
            float head2X = endX - headLen * (dirX * cosA + dirY * sinA);
            float head2Y = endY - headLen * (-dirX * sinA + dirY * cosA);
            
            // 箭头头部：四个顶点（两条线段）
            vectorVerts.insert(vectorVerts.end(), {endX, endY, 0.0f, 0.0f, 0.0f});
            vectorVerts.insert(vectorVerts.end(), {head1X, head1Y, 0.0f, 0.0f, 0.0f});
            vectorVerts.insert(vectorVerts.end(), {endX, endY, 0.0f, 0.0f, 0.0f});
            vectorVerts.insert(vectorVerts.end(), {head2X, head2Y, 0.0f, 0.0f, 0.0f});
        }
    }
    
    if (!vectorVerts.empty())
    {
        // 上传顶点数据到GPU
        glBindVertexArray(vectorVAO_);
        glBindBuffer(GL_ARRAY_BUFFER, vectorVBO_);
        glBufferData(GL_ARRAY_BUFFER, vectorVerts.size() * sizeof(float),
                     vectorVerts.data(), GL_DYNAMIC_DRAW);
        // 功能：分配并上传缓冲区数据
        // 参数4：GL_DYNAMIC_DRAW表示数据会频繁修改
        
        // 配置顶点属性
        glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void *)0);
        // 功能：指定顶点属性的数据格式
        // 参数1：属性索引（对应着色器中layout(location=0)）
        // 参数2：组件数量（2 = x,y位置）
        // 参数3：数据类型（GL_FLOAT）
        // 参数4：是否归一化（GL_FALSE）
        // 参数5：步长（5个float = 2位置 + 3颜色）
        // 参数6：偏移量（0 = 从头开始）
        glEnableVertexAttribArray(0);
        // 功能：启用顶点属性数组
        
        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), 
                              (void *)(2 * sizeof(float)));
        // 参数1：属性索引1（颜色）
        // 参数2：3个组件（r,g,b）
        // 参数6：偏移2个float（跳过位置）
        glEnableVertexAttribArray(1);
        
        // 绘制箭头
        glLineWidth(2.0f);
        // 功能：设置线条宽度为2像素
        
        glDrawArrays(GL_LINES, 0, vectorVerts.size() / 5);
        // 功能：绘制线段
        // 参数1：GL_LINES表示每两个顶点构成一条线段
        // 参数2：起始顶点索引
        // 参数3：顶点数量（每个顶点5个float）
    }
}
```

**矢量箭头渲染流程：**
```
速度数据（CPU端：velocityU_, velocityV_）
  ↓
CPU: 遍历网格，每隔step个格子
  ↓
CPU: 计算箭头几何（起点、终点、头部顶点）
  ↓
CPU: 生成OpenGL顶点数组（位置+颜色）
  ↓
glBufferData: CPU → GPU上传顶点
  ↓
glDrawArrays: GPU绘制线段
```

### 4. 矢量密度调整

#### 4.1 用户调整密度滑块

```cpp
// main.cpp: renderUI() - line 495
if (showVectors)  // 仅在矢量显示开启时可见
{
    int vectorDensity = renderer.getVectorDensity();  // 获取当前密度
    if (ImGui::SliderInt(u8"矢量箭头间隔", &vectorDensity, 5, 50, u8"%d 格"))
    // ImGui::SliderInt功能：创建整数滑块
    // 参数1：标签
    // 参数2：变量指针
    // 参数3：最小值（5格间隔 = 密集）
    // 参数4：最大值（50格间隔 = 稀疏）
    // 参数5：显示格式
    {
        renderer.setVectorDensity(vectorDensity);  // 设置新密度
    }
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), 
                       u8"（值越小箭头越密集）");
}
```

```cpp
// renderer.h: Renderer类 - line 128
void setVectorDensity(int density) { vectorDensity_ = std::max(2, density); }
// std::max确保最小值为2，避免过于密集
int getVectorDensity() const { return vectorDensity_; }
```

```cpp
// renderer.h: 成员变量 - line 214
int vectorDensity_ = 20;  // 默认每20格绘制一个箭头
```

#### 4.2 密度参数影响箭头数量

```cpp
// renderer.cpp: Renderer::render() - line 997
int step = vectorDensity_;  // 从成员变量读取

// 遍历网格时使用step作为间隔
for (int j = step / 2; j < ny_; j += step)
// 起始位置：step/2（居中对齐）
// 步长：step
{
    for (int i = step / 2; i < nx_; i += step)
    {
        // 每隔step个格子生成一个箭头
    }
}
```

**密度效果：**
- `vectorDensity_ = 5`：每5格一个箭头 → 密集
- `vectorDensity_ = 20`：每20格一个箭头 → 中等
- `vectorDensity_ = 50`：每50格一个箭头 → 稀疏

**箭头总数计算：**
```
箭头数量 ≈ (nx / step) × (ny / step)

例如1024×512网格：
- step=5:  约 (1024/5) × (512/5) ≈ 20,000个箭头
- step=20: 约 (1024/20) × (512/20) ≈ 1,300个箭头
- step=50: 约 (1024/50) × (512/50) ≈ 200个箭头
```

#### 4.3 密度参数影响箭头大小

```cpp
// renderer.cpp: Renderer::render() - line 1004
float maxArrowLength = std::min(cellWidth, cellHeight) * (step * 0.8f);
// 箭头最大长度与step成正比
// step越大，箭头间隔大，箭头也更长（避免视觉上过于稀疏）
```

**视觉效果：**
- 密集模式（step=5）：箭头短而密集，适合查看局部细节
- 稀疏模式（step=50）：箭头长而稀疏，适合查看整体流场

### 5. 参数更新时机和性能

#### 5.1 色图切换性能

```
用户选择新色图
  ↓
generateXXXColormap: CPU生成256×3 RGB数据（~10μs）
  ↓
glTexImage1D: CPU→GPU上传3KB（~50μs）
  ↓
总开销：~60μs（可忽略）
```

#### 5.2 范围调整性能

```
用户移动滑块
  ↓
修改全局变量（立即生效）
  ↓
下一帧render()时glUniform1f传递（~1μs × 2）
  ↓
片元着色器重新计算归一化（实时）
  ↓
总开销：~2μs（可忽略）
```

#### 5.3 矢量显示性能

**开启矢量显示：**
```
首次开启（或切换到速度场）
  ↓
GPU→CPU传输u,v（非零拷贝每次触发，零拷贝首次触发）
  ↓
1024×512网格：2MB × 2 = 4MB
  ↓
传输时间：~1-2ms（PCIe Gen3 x16）
```

**每帧绘制开销：**
```
step=20，约1300个箭头
  ↓
CPU生成顶点：1300箭头 × 6顶点 × 5float = 156KB（~0.1ms）
  ↓
glBufferData上传：156KB（~0.05ms）
  ↓
glDrawArrays绘制：7800个顶点（~0.1ms）
  ↓
总开销：~0.25ms/帧
```

#### 5.4 密度调整性能

```
用户调整滑块
  ↓
修改vectorDensity_（立即生效）
  ↓
下一帧render()时重新生成顶点
  ↓
顶点数量变化影响性能：

step=5:  20000箭头，120000顶点，~2ms/帧
step=20: 1300箭头，  7800顶点，  ~0.25ms/帧
step=50: 200箭头，   1200顶点，  ~0.05ms/帧
```

### 6. UI参数完整数据流图

```
┌─────────────────────────────────────────────────────────────┐
│                        UI控制面板                            │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │色图选择  │  │范围滑块  │  │矢量开关  │  │密度滑块  │   │
│  └─────┬────┘  └─────┬────┘  └─────┬────┘  └─────┬────┘   │
└────────┼─────────────┼─────────────┼─────────────┼─────────┘
         │             │             │             │
         │             │             │             │
         ▼             ▼             ▼             ▼
    ┌────────┐   ┌────────┐   ┌────────┐   ┌────────┐
    │colormap│   │p_min_  │   │show    │   │vector  │
    │        │   │ratio等 │   │Vectors_│   │Density_│
    └────┬───┘   └────┬───┘   └────┬───┘   └────┬───┘
         │            │            │            │
         │            │            │            │
         ▼            ▼            ▼            ▼
    generate     calculate   condition    control
    colormap      minVal      check        loop step
         │            │            │            │
         ▼            ▼            ▼            ▼
    ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
    │glTex    │  │glUniform│  │速度数据 │  │箭头生成 │
    │Image1D  │  │1f()     │  │更新     │  │循环     │
    └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘
         │            │            │            │
         ▼            ▼            ▼            ▼
    ┌────────────────────────────────────────────────┐
    │              片元着色器/顶点生成                │
    │  texture()查色图  归一化映射  生成箭头顶点     │
    └───────────────────┬────────────────────────────┘
                        │
                        ▼
                   ┌─────────┐
                   │ 屏幕输出 │
                   └─────────┘
```

### 7. 总结

**UI参数特点：**

1. **色图选择**
   - 触发CPU端色图生成
   - 上传小量数据（3KB）到GPU
   - 开销可忽略

2. **范围调整**
   - 仅修改uniform变量
   - 无数据传输
   - 实时生效

3. **矢量显示**
   - 需要CPU端速度数据
   - 零拷贝模式下触发GPU→CPU传输
   - 每帧CPU生成顶点

4. **密度调整**
   - 控制采样步长
   - 影响箭头数量和大小
   - 直接影响性能

**性能权衡：**
- 色图和范围调整：几乎零开销
- 矢量显示：牺牲零拷贝优势，但提供重要的流场可视化
- 密度调整：允许用户在性能和细节之间平衡
