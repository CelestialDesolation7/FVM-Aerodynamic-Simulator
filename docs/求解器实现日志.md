# 求解器实现日志

本文档作为实现整个`solver`类的草稿使用。

## 1. 变量列表

### 1.1 命名规范约定

| 结构       | 含义                   | 例子                                                         |
| :--------- | :--------------------- | :----------------------------------------------------------- |
| **前缀**   | 变量的类型             | `flux_` (通量), `d_` (设备端数组), `dFx_` (通量的空间导数/变化率) |
| **物理量** | 这个变量里装着什么成分 | `rho` (质量), `rho_u` (x动量), `rho_v` (y动量), `E` (能量)   |
| **后缀**   | 这个变量归哪个方向管   | `_x` (管左右进出), `_y` (管上下进出), 没后缀 (表示标量或中心量) |

### 1.2 守恒物理量

**守恒变量（Conservative Variables）**：直接参与守恒方程的变量，由显存持久化存储。

以下的密度均为相对体积而言的密度。

| 代码变量名 | 数学符号 | 含义详解 (位置、方向、依赖关系)                              | 来源 (生成者) | 用途 (消费者) |
| ---------- | -------- | ------------------------------------------------------------ | ------------- | ------------- |
| `rho`      | $\rho$   | **【位置】中心** <br/> **【含义】** 方格内气体密度。 <br/> **【依赖】** 由显存存储，作为整个求解器维护的对象。 |               |               |
| `rho_u`    | $\rho u$ | **【位置】中心** <br/> **【含义】** x轴方向动量密度。 <br/> **【依赖】** 由显存存储，作为整个求解器维护的对象。 |               |               |
| `rho_v`    | $\rho v$ | **【位置】中心** <br/> **【含义】** y轴方向动量密度。 <br/> **【依赖】** 由显存存储，作为整个求解器维护的对象。 |               |               |
| `E`        | $E$      | **【位置】中心** <br/> **【含义】** 能量密度。 <br/> **【依赖】** 由显存存储，作为整个求解器维护的对象。 |               |               |

## 2. 求解器链的函数定义

### 2.1 入口

```cpp
CFDSolver::step(SimParams &params)
```

### 2.2 计算SDF场并转化为Cell分类

```cpp
__device__ float sdfCircle(float px, float py, float cx, float cy, float r)
__device__ float sdfStar(float px, float py, float cx, float cy, float r, float rotation)
__device__ float sdfDiamond(float px, float py, float cx, float cy, float r, float rotation)
__device__ float sdfCapsule(float px, float py, float cx, float cy, float r, float rotation)
__device__ float sdfTriangle(float px, float py, float cx, float cy, float r, float rotation)
    
__device__ float computeShapeSDF(float px, float py, float cx, float cy, float r,
                                 float rotation, int shapeType)
    
__global__ void computeSDFKernel(float *sdf, uint8_t *cell_type,
                                 float obs_x, float obs_y, float obs_r,
                                 float rotation, int shapeType,
                                 float dx, float dy, int nx, int ny)
    
void launchComputeSDFKernel(float *sdf, uint8_t *cell_type,
                            const SimParams &params, int nx, int ny);
```

用到工具函数：

```cpp
__device__ float distToSegment(float px, float py, float ax, float ay, float bx, float by)
__device__ float cross2d(float ax, float ay, float bx, float by)
```

### 2.3 对流更新

#### 2.3.1 原始变量计算

```cpp
void launchComputePrimitivesKernel(const float *rho, const float *rho_u,
                                   const float *rho_v, const float *E,
                                   const float *rho_e,
                                   float *u, float *v, float *p, float *T,
                                   int nx, int ny);
```

#### 2.3.2 通量计算

```cpp
void launchComputeFluxesKernel(const float *rho, const float *rho_u,
                               const float *rho_v, const float *E,
                               const float *rho_e, // 内能，用于双能量方法
                               const float *u, const float *v,
                               const float *p, const float *T,
                               const uint8_t *cell_type,
                               float *flux_rho_x, float *flux_rho_u_x,
                               float *flux_rho_v_x, float *flux_E_x,
                               float *flux_rho_e_x,
                               float *flux_rho_y, float *flux_rho_u_y,
                               float *flux_rho_v_y, float *flux_E_y,
                               float *flux_rho_e_y,
                               const SimParams &params, int nx, int ny);
```

#### 2.3.3 使用通量更新状态

```cpp
void launchUpdateKernel(const float *rho, const float *rho_u,
                        const float *rho_v, const float *E, const float *rho_e,
                        const float *flux_rho_x, const float *flux_rho_u_x,
                        const float *flux_rho_v_x, const float *flux_E_x,
                        const float *flux_rho_e_x,
                        const float *flux_rho_y, const float *flux_rho_u_y,
                        const float *flux_rho_v_y, const float *flux_E_y,
                        const float *flux_rho_e_y,
                        const uint8_t *cell_type,
                        float *rho_new, float *rho_u_new,
                        float *rho_v_new, float *E_new, float *rho_e_new,
                        const SimParams &params, int nx, int ny);
```

### 2.4 粘性更新（若开启）

#### 2.4.1 入口

```cpp
void launchComputeViscosityKernel(const float *T, float *mu, float *k, int nx, int ny);
```

#### 2.4.2 原始变量计算

```cpp
void launchComputePrimitivesKernel(const float *rho, const float *rho_u,
                                   const float *rho_v, const float *E,
                                   const float *rho_e,
                                   float *u, float *v, float *p, float *T,
                                   int nx, int ny);
```

#### 2.4.3 物性计算

```cpp
void launchComputeViscosityKernel(const float *T, float *mu, float *k, int nx, int ny);
```

#### 2.4.4 摩擦和热通量计算

```cpp
void launchComputeStressTensorKernel(const float *u, const float *v, const float *mu,
                                     float *tau_xx, float *tau_yy, float *tau_xy,
                                     const uint8_t *cell_type,
                                     float dx, float dy, int nx, int ny);

void launchComputeHeatFluxKernel(const float *T, const float *k,
                                 float *qx, float *qy,
                                 const uint8_t *cell_type,
                                 float dx, float dy, int nx, int ny);
```

#### 2.4.5 更新守恒变量

```cpp
void launchUpdateKernel(const float *rho, const float *rho_u,
                        const float *rho_v, const float *E, const float *rho_e,
                        const float *flux_rho_x, const float *flux_rho_u_x,
                        const float *flux_rho_v_x, const float *flux_E_x,
                        const float *flux_rho_e_x,
                        const float *flux_rho_y, const float *flux_rho_u_y,
                        const float *flux_rho_v_y, const float *flux_E_y,
                        const float *flux_rho_e_y,
                        const uint8_t *cell_type,
                        float *rho_new, float *rho_u_new,
                        float *rho_v_new, float *E_new, float *rho_e_new,
                        const SimParams &params, int nx, int ny);
```

### 2.5 边界条件修正

```cpp
void launchApplyBoundaryConditionsKernel(float *rho, float *rho_u, float *rho_v, float *E,
                                         float *rho_e,
                                         const uint8_t *cell_type, const float *sdf,
                                         const SimParams &params, int nx, int ny);
```

- **Thread (线程)**：最小执行单位，对应一个网格单元。
- **Block (线程块)**：一组线程，它们共享一块快速的共享内存（Shared Memory），并且可以同步。
	通常包含 128~1024 个线程。
- **Grid (网格)**：所有 Block 的集合，覆盖整个计算任务（整个物理场）。
- threadIdx.x/y：线程在 Block 内的坐标。
- blockIdx.x/y：Block 在 Grid 内的坐标。
- blockDim.x/y：一个 Block 的尺寸（例如 16x16）。

## 3. 2026/2/8 重构优化日志

本次重构主要修正了 Riemann 求解器的物理错误，并针对计算链进行了深度优化，消除了大量冗余计算与内存分配开销。

### 3.1 物理与逻辑修正

1.  **Riemann 求解器修正**：
    *   **HLLC X 方向**：修正 Roe 声速计算，补回遗漏的垂直速度分量 $v$。
    *   **HLL Y 方向**：修正 Roe 声速计算，补回遗漏的水平速度分量 $u$。
    *   **HLLC Y 方向**：完全重写。原实现未使用 Roe 平均，现统一为标准的 Roe 平均计算，保证 XY 方向精度一致。
2.  **马赫数统计修正**：
    *   旧逻辑错误使用全局来流声速作为分母：$Ma = (|v|+c)/c_{\infty}$。
    *   新逻辑修正为局部马赫数：$Ma_{local} = |v_{local}| / c_{local}$。

### 3.2 性能与架构优化

1.  **消除冗余计算**：
    *   **Primitive 计算后置**：将 `computePrimitives` 从 `step` 头部移至尾部（BC 应用之后）。
        *   收益：`computeStableTimeStep` 可直接复用上一步结果，无需重复计算。每步节省 1 次全场计算。
    *   **粘性核函数融合**：将 `computeViscosity` + `computeStressTensor` + `computeHeatFlux` 合并为单次核函数调用 `computeViscousTermsKernel`。
        *   收益：减少显存读写（消除中间变量 $k$ 的读写），减少 2 次内核启动开销。
    *   **Update 核函数简化**：`updateKernel` 不再从守恒量反算原始变量，改为直接传入现成的 $u, v, p$。
        *   收益：每网格节省 10+ 次浮点除法与开方运算。
    *   **Flux 核函数清理**：移除仅传入但未使用的守恒量指针参数。
2.  **内存管理**：
    *   **持久化归约缓冲区**：`d_reduction_buffer_` 改为预分配（64KB），复用于所有归约操作（温度、粘性、马赫数）。
        *   收益：消除每步 3-4 次 `cudaMalloc/cudaFree` 调用（每秒节省约 0.5ms 系统开销）。

### 3.3 重构后的计算链 (CFDSolver::step)

```cpp
void CFDSolver::step(SimParams &params)
{
    // 0. 更新 SDF 障碍物场 (处理动态障碍物)
    launchComputeSDFKernel(...);

    // 1. 粘性项计算 (融合内核，仅开启粘性时执行)
    if (params.enable_viscosity) {
        // 单次启动完成：温度 -> 粘性系数，速度/温度 -> 应力张量/热通量
        launchComputeViscousTermsKernel(u, v, T, mu, tau..., q..., ...);
        
        // 扩散步：半步更新守恒量
        launchDiffusionStepKernel(...);
    }

    // 2. 无粘通量计算 (MUSCL-Hancock / Riemann Solver)
    // 仅需传入原始变量 (rho, u, v, p)，不再传入未使用的守恒量
    launchComputeFluxesKernel(rho, u, v, p, ..., flux_arrays, ...);

    // 3. 守恒量更新 (有限体积法)
    // 直接复用原始变量 (u, v, p) 计算对流项，避免重复除法
    launchUpdateKernel(rho, rho_u, ..., u, v, p, flux_arrays, ..., rho_new, ...);
    
    // 4. 双缓冲交换
    std::swap(d_curr, d_next);

    // 5. 应用边界条件 (包含 Ghost Cell 处理)
    launchApplyBoundaryConditionsKernel(...);

    // 6. [关键优化] 预计算下一帧所需的原始变量
    // 为可视化、统计和下一步的 CFL 计算准备数据
    launchComputePrimitivesKernel(d_rho_, d_rho_u_, d_rho_v_, d_E_, d_rho_e_,
                                  d_u_, d_v_, d_p_, d_T_, _nx, _ny);

    // 更新仿真时间
    params.t_current += params.dt;
}
```

























