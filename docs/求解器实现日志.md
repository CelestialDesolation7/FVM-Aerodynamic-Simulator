# 求解器实现日志

本文档作为实现整个`solver`类的草稿使用。

## 1. 变量列表

### 1.1 命名规范约定

| 结构       | 含义                   | 例子                                                         |
| :--------- | :--------------------- | :----------------------------------------------------------- |
| **前缀**   | 变量的类型             | `flux_` (通量), `d_` (设备端数组), `dFx_` (通量的空间导数/变化率) |
| **物理量** | 这个变量里装着什么成分 | `rho` (质量), `rho_u` (x动量), `rho_v` (y动量), `E` (能量)   |
| **后缀**   | 这个变量归哪个方向管   | `_x` (管左右进出), `_y` (管上下进出), 没后缀 (表示标量或中心量) |

### 1.2 守恒物理量

**守恒变量（Conservative Variables）**：直接参与守恒方程的变量，由显存持久化存储。

以下的密度均为相对体积而言的密度。

| 代码变量名 | 数学符号 | 含义详解 (位置、方向、依赖关系)                              | 来源 (生成者) | 用途 (消费者) |
| ---------- | -------- | ------------------------------------------------------------ | ------------- | ------------- |
| `rho`      | $\rho$   | **【位置】中心** <br/> **【含义】** 方格内气体密度。 <br/> **【依赖】** 由显存存储，作为整个求解器维护的对象。 |               |               |
| `rho_u`    | $\rho u$ | **【位置】中心** <br/> **【含义】** x轴方向动量密度。 <br/> **【依赖】** 由显存存储，作为整个求解器维护的对象。 |               |               |
| `rho_v`    | $\rho v$ | **【位置】中心** <br/> **【含义】** y轴方向动量密度。 <br/> **【依赖】** 由显存存储，作为整个求解器维护的对象。 |               |               |
| `E`        | $E$      | **【位置】中心** <br/> **【含义】** 能量密度。 <br/> **【依赖】** 由显存存储，作为整个求解器维护的对象。 |               |               |

## 2. 求解器链的函数定义

### 2.1 入口

```cpp
CFDSolver::step(SimParams &params)
```

### 2.2 计算SDF场并转化为Cell分类

```cpp
__device__ float sdfCircle(float px, float py, float cx, float cy, float r)
__device__ float sdfStar(float px, float py, float cx, float cy, float r, float rotation)
__device__ float sdfDiamond(float px, float py, float cx, float cy, float r, float rotation)
__device__ float sdfCapsule(float px, float py, float cx, float cy, float r, float rotation)
__device__ float sdfTriangle(float px, float py, float cx, float cy, float r, float rotation)
    
__device__ float computeShapeSDF(float px, float py, float cx, float cy, float r,
                                 float rotation, int shapeType)
    
__global__ void computeSDFKernel(float *sdf, uint8_t *cell_type,
                                 float obs_x, float obs_y, float obs_r,
                                 float rotation, int shapeType,
                                 float dx, float dy, int nx, int ny)
    
void launchComputeSDFKernel(float *sdf, uint8_t *cell_type,
                            const SimParams &params, int nx, int ny);
```

用到工具函数：

```cpp
__device__ float distToSegment(float px, float py, float ax, float ay, float bx, float by)
__device__ float cross2d(float ax, float ay, float bx, float by)
```

### 2.3 对流更新

#### 2.3.1 原始变量计算

```cpp
void launchComputePrimitivesKernel(const float *rho, const float *rho_u,
                                   const float *rho_v, const float *E,
                                   const float *rho_e,
                                   float *u, float *v, float *p, float *T,
                                   int nx, int ny);
```

#### 2.3.2 通量计算

```cpp
void launchComputeFluxesKernel(const float *rho, const float *rho_u,
                               const float *rho_v, const float *E,
                               const float *rho_e, // 内能，用于双能量方法
                               const float *u, const float *v,
                               const float *p, const float *T,
                               const uint8_t *cell_type,
                               float *flux_rho_x, float *flux_rho_u_x,
                               float *flux_rho_v_x, float *flux_E_x,
                               float *flux_rho_e_x,
                               float *flux_rho_y, float *flux_rho_u_y,
                               float *flux_rho_v_y, float *flux_E_y,
                               float *flux_rho_e_y,
                               const SimParams &params, int nx, int ny);
```

#### 2.3.3 使用通量更新状态

```cpp
void launchUpdateKernel(const float *rho, const float *rho_u,
                        const float *rho_v, const float *E, const float *rho_e,
                        const float *flux_rho_x, const float *flux_rho_u_x,
                        const float *flux_rho_v_x, const float *flux_E_x,
                        const float *flux_rho_e_x,
                        const float *flux_rho_y, const float *flux_rho_u_y,
                        const float *flux_rho_v_y, const float *flux_E_y,
                        const float *flux_rho_e_y,
                        const uint8_t *cell_type,
                        float *rho_new, float *rho_u_new,
                        float *rho_v_new, float *E_new, float *rho_e_new,
                        const SimParams &params, int nx, int ny);
```

### 2.4 粘性更新（若开启）

#### 2.4.1 入口

```cpp
void launchComputeViscosityKernel(const float *T, float *mu, float *k, int nx, int ny);
```

#### 2.4.2 原始变量计算

```cpp
void launchComputePrimitivesKernel(const float *rho, const float *rho_u,
                                   const float *rho_v, const float *E,
                                   const float *rho_e,
                                   float *u, float *v, float *p, float *T,
                                   int nx, int ny);
```

#### 2.4.3 物性计算

```cpp
void launchComputeViscosityKernel(const float *T, float *mu, float *k, int nx, int ny);
```

#### 2.4.4 摩擦和热通量计算

```cpp
void launchComputeStressTensorKernel(const float *u, const float *v, const float *mu,
                                     float *tau_xx, float *tau_yy, float *tau_xy,
                                     const uint8_t *cell_type,
                                     float dx, float dy, int nx, int ny);

void launchComputeHeatFluxKernel(const float *T, const float *k,
                                 float *qx, float *qy,
                                 const uint8_t *cell_type,
                                 float dx, float dy, int nx, int ny);
```

#### 2.4.5 更新守恒变量

```cpp
void launchUpdateKernel(const float *rho, const float *rho_u,
                        const float *rho_v, const float *E, const float *rho_e,
                        const float *flux_rho_x, const float *flux_rho_u_x,
                        const float *flux_rho_v_x, const float *flux_E_x,
                        const float *flux_rho_e_x,
                        const float *flux_rho_y, const float *flux_rho_u_y,
                        const float *flux_rho_v_y, const float *flux_E_y,
                        const float *flux_rho_e_y,
                        const uint8_t *cell_type,
                        float *rho_new, float *rho_u_new,
                        float *rho_v_new, float *E_new, float *rho_e_new,
                        const SimParams &params, int nx, int ny);
```

### 2.5 边界条件修正

```cpp
void launchApplyBoundaryConditionsKernel(float *rho, float *rho_u, float *rho_v, float *E,
                                         float *rho_e,
                                         const uint8_t *cell_type, const float *sdf,
                                         const SimParams &params, int nx, int ny);
```

- **Thread (线程)**：最小执行单位，对应一个网格单元。
- **Block (线程块)**：一组线程，它们共享一块快速的共享内存（Shared Memory），并且可以同步。
	通常包含 128~1024 个线程。
- **Grid (网格)**：所有 Block 的集合，覆盖整个计算任务（整个物理场）。
- threadIdx.x/y：线程在 Block 内的坐标。
- blockIdx.x/y：Block 在 Grid 内的坐标。
- blockDim.x/y：一个 Block 的尺寸（例如 16x16）。

























